<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GelfMessage.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">logstash logging connectors</a> &gt; <a href="index.source.html" class="el_package">biz.paluch.logging.gelf.intern</a> &gt; <span class="el_source">GelfMessage.java</span></div><h1>GelfMessage.java</h1><pre class="source lang-java linenums">package biz.paluch.logging.gelf.intern;

import static biz.paluch.logging.gelf.intern.JsonWriter.writeKeyValueSeparator;
import static biz.paluch.logging.gelf.intern.JsonWriter.writeMapEntry;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.math.BigDecimal;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.zip.GZIPOutputStream;

/**
 * Represents a Gelf message. A Gelf message contains all required Fields according to the Gelf Spec.
 *
 * A {@link GelfMessage} can be converted to {@link #toJson()}, to {@link #toTCPBuffer()} and to {@link #toUDPBuffers()}. It
 * also provides methods accepting {@link ByteBuffer} to reduce GC pressure.
 *
 * @author https://github.com/t0xa/gelfj
 * @author Mark Paluch
 * @see &lt;a href=&quot;http://docs.graylog.org/en/2.0/pages/gelf.html&quot;&gt;http://docs.graylog.org/en/2.0/pages/gelf.html&lt;/a&gt;
 */
public class GelfMessage {

    public static final String FIELD_HOST = &quot;host&quot;;
    public static final String FIELD_SHORT_MESSAGE = &quot;short_message&quot;;
    public static final String FIELD_FULL_MESSAGE = &quot;full_message&quot;;
    public static final String FIELD_TIMESTAMP = &quot;timestamp&quot;;
    public static final String FIELD_LEVEL = &quot;level&quot;;
    public static final String FIELD_FACILITY = &quot;facility&quot;;
    public static final String ID_NAME = &quot;id&quot;;

    /**
     * Discover the field type by trying to parse it.
     */
    public static final String FIELD_TYPE_DISCOVER = &quot;discover&quot;;

    /**
     * String field type.
     */
    public static final String FIELD_TYPE_STRING = &quot;String&quot;;

    /**
     * long field type. Zero if value cannot be converted.
     */
    public static final String FIELD_TYPE_LONG = &quot;long&quot;;

    /**
     * Long field type. Null if value cannot be converted.
     */
    public static final String FIELD_TYPE_LONG2 = &quot;Long&quot;;

    /**
     * double field type. Zero if value cannot be converted.
     */
    public static final String FIELD_TYPE_DOUBLE = &quot;double&quot;;

    /**
     * Double field type. Null if value cannot be converted.
     */
    public static final String FIELD_TYPE_DOUBLE2 = &quot;Double&quot;;

    /*
     * Default field type: Discover
     */
    public static final String FIELD_TYPE_DEFAULT = FIELD_TYPE_DISCOVER;

    public static final String GELF_VERSION_1_0 = &quot;1.0&quot;;
    public static final String GELF_VERSION_1_1 = &quot;1.1&quot;;

    public static final String GELF_VERSION = GELF_VERSION_1_0;

    public static final String DEFAULT_FACILITY = &quot;logstash-gelf&quot;;
    public static final int DEFAULT_MESSAGE_SIZE = 8192;
    public static final int DEFAUL_LEVEL = 7;

<span class="fc" id="L79">    private static final byte[] GELF_CHUNKED_ID = new byte[] { 0x1e, 0x0f };</span>
<span class="fc" id="L80">    private static final BigDecimal TIME_DIVISOR = new BigDecimal(1000);</span>
<span class="fc" id="L81">    private static final byte[] NONE = lastFourAsciiBytes(&quot;none&quot;);</span>

<span class="fc" id="L83">    private String version = GELF_VERSION;</span>
    private String host;
<span class="fc" id="L85">    private byte[] hostBytes = NONE;</span>
    private String shortMessage;
    private String fullMessage;
    private long javaTimestamp;
    private String level;
<span class="fc" id="L90">    private String facility = DEFAULT_FACILITY;</span>
<span class="fc" id="L91">    private Map&lt;String, String&gt; additonalFields = new HashMap&lt;String, String&gt;();</span>
<span class="fc" id="L92">    private Map&lt;String, String&gt; additionalFieldTypes = new HashMap&lt;String, String&gt;();</span>
<span class="fc" id="L93">    private int maximumMessageSize = DEFAULT_MESSAGE_SIZE;</span>

<span class="fc" id="L95">    public GelfMessage() {</span>
<span class="fc" id="L96">    }</span>

<span class="fc" id="L98">    public GelfMessage(String shortMessage, String fullMessage, long timestamp, String level) {</span>

<span class="fc" id="L100">        this.shortMessage = shortMessage;</span>
<span class="fc" id="L101">        this.fullMessage = fullMessage;</span>
<span class="fc" id="L102">        this.javaTimestamp = timestamp;</span>
<span class="fc" id="L103">        this.level = level;</span>
<span class="fc" id="L104">    }</span>

    /**
     * Create a JSON representation for this {@link GelfMessage}. Additional fields are prefixed with underscore {@code _}.
     *
     * @return the JSON string.
     */
    public String toJson() {
<span class="fc" id="L112">        return toJson(&quot;_&quot;);</span>
    }

    /**
     * Create a JSON representation for this {@link GelfMessage}. Additional fields are prefixed with
     * {@code additionalFieldPrefix}.
     * 
     * @param additionalFieldPrefix must not be {@literal null}
     * @return the JSON string.
     */
    public String toJson(String additionalFieldPrefix) {
<span class="fc" id="L123">        return new String(toJsonByteArray(additionalFieldPrefix), Charsets.UTF8);</span>
    }

    private byte[] toJsonByteArray(String additionalFieldPrefix) {

<span class="fc" id="L128">        ByteArrayOutputStream buffer = new ByteArrayOutputStream();</span>
<span class="fc" id="L129">        toJson(OutputAccessor.from(buffer), additionalFieldPrefix);</span>

<span class="fc" id="L131">        return buffer.toByteArray();</span>
    }

    /**
     * Create a JSON representation for this {@link GelfMessage} and write it to the {@link ByteBuffer}. Additional fields are
     * prefixed with {@code additionalFieldPrefix}.
     * 
     * @param byteBuffer must not be {@literal null}
     * @param additionalFieldPrefix must not be {@literal null}
     */
    public void toJson(ByteBuffer byteBuffer, String additionalFieldPrefix) {
<span class="fc" id="L142">        toJson(OutputAccessor.from(byteBuffer), additionalFieldPrefix);</span>
<span class="fc" id="L143">    }</span>

    protected void toJson(OutputAccessor out, String additionalFieldPrefix) {

<span class="fc" id="L147">        JsonWriter.writeObjectStart(out);</span>

<span class="fc" id="L149">        boolean hasFields = writeIfNotEmpty(out, false, FIELD_HOST, getHost());</span>

<span class="fc bfc" id="L151" title="All 2 branches covered.">        if (!isEmpty(shortMessage)) {</span>
<span class="fc" id="L152">            hasFields = writeIfNotEmpty(out, hasFields, FIELD_SHORT_MESSAGE, getShortMessage());</span>
        }

<span class="fc" id="L155">        hasFields = writeIfNotEmpty(out, hasFields, FIELD_FULL_MESSAGE, getFullMessage());</span>

<span class="fc bfc" id="L157" title="All 2 branches covered.">        if (getJavaTimestamp() != 0) {</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">            if (GELF_VERSION_1_1.equals(version)) {</span>
<span class="fc" id="L159">                hasFields = writeIfNotEmpty(out, hasFields, FIELD_TIMESTAMP, getTimestampAsBigDecimal().doubleValue());</span>
            } else {
<span class="fc" id="L161">                hasFields = writeIfNotEmpty(out, hasFields, FIELD_TIMESTAMP, getTimestampAsBigDecimal().toString());</span>
            }
        }

<span class="fc bfc" id="L165" title="All 2 branches covered.">        if (!isEmpty(getLevel())) {</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">            if (GELF_VERSION_1_1.equals(version)) {</span>
                int level;
                try {
<span class="fc" id="L169">                    level = Integer.parseInt(getLevel());</span>
<span class="nc" id="L170">                } catch (NumberFormatException ex) {</span>
                    // fallback on the default value
<span class="nc" id="L172">                    level = DEFAUL_LEVEL;</span>
<span class="fc" id="L173">                }</span>
<span class="fc" id="L174">                hasFields = writeIfNotEmpty(out, hasFields, FIELD_LEVEL, level);</span>
<span class="fc" id="L175">            } else {</span>
<span class="fc" id="L176">                hasFields = writeIfNotEmpty(out, hasFields, FIELD_LEVEL, getLevel());</span>
            }
        }

<span class="fc bfc" id="L180" title="All 2 branches covered.">        if (!isEmpty(getFacility())) {</span>
<span class="fc" id="L181">            hasFields = writeIfNotEmpty(out, hasFields, FIELD_FACILITY, getFacility());</span>
        }

<span class="fc bfc" id="L184" title="All 2 branches covered.">        for (Map.Entry&lt;String, String&gt; additionalField : additonalFields.entrySet()) {</span>
<span class="pc bpc" id="L185" title="1 of 4 branches missed.">            if (!ID_NAME.equals(additionalField.getKey()) &amp;&amp; additionalField.getValue() != null) {</span>
<span class="fc" id="L186">                String value = additionalField.getValue();</span>
<span class="fc" id="L187">                String fieldType = additionalFieldTypes.get(additionalField.getKey());</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">                if (fieldType == null) {</span>
<span class="fc" id="L189">                    fieldType = FIELD_TYPE_DEFAULT;</span>
                }
<span class="fc" id="L191">                Object result = getAdditionalFieldValue(value, fieldType);</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">                if (result != null) {</span>
<span class="fc" id="L193">                    hasFields = writeIfNotEmpty(out, hasFields, additionalFieldPrefix + additionalField.getKey(), result);</span>
                }
            }
<span class="fc" id="L196">        }</span>

<span class="fc" id="L198">        JsonWriter.writeObjectEnd(out);</span>
<span class="fc" id="L199">    }</span>

    /**
     * Write a Value to JSON if the value is not empty.
     */
    private static boolean writeIfNotEmpty(OutputAccessor out, boolean hasFields, String field, Object value) {

<span class="fc bfc" id="L206" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L207">            return hasFields;</span>
        }

<span class="fc bfc" id="L210" title="All 2 branches covered.">        if (value instanceof String) {</span>

<span class="fc bfc" id="L212" title="All 2 branches covered.">            if (GelfMessage.isEmpty((String) value)) {</span>
<span class="fc" id="L213">                return hasFields;</span>
            }

<span class="fc bfc" id="L216" title="All 2 branches covered.">            if (hasFields) {</span>
<span class="fc" id="L217">                writeKeyValueSeparator(out);</span>
            }

<span class="fc" id="L220">            writeMapEntry(out, field, value);</span>

<span class="fc" id="L222">            return true;</span>
        }

<span class="fc bfc" id="L225" title="All 2 branches covered.">        if (hasFields) {</span>
<span class="fc" id="L226">            writeKeyValueSeparator(out);</span>
        }

<span class="fc" id="L229">        writeMapEntry(out, field, value);</span>

<span class="fc" id="L231">        return true;</span>
    }

    /**
     * Get the field value as requested data type.
     *
     * @param value the value as string
     * @param fieldType see field types
     * @return the field value in the appropriate data type or {@literal null}.
     */
    private Object getAdditionalFieldValue(String value, String fieldType) {

<span class="fc" id="L243">        Object result = null;</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">        if (fieldType.equalsIgnoreCase(FIELD_TYPE_DISCOVER)) {</span>
            try {
                try {
                    // try adding the value as a long
<span class="fc" id="L248">                    result = Long.parseLong(value);</span>
<span class="fc" id="L249">                } catch (NumberFormatException ex) {</span>
                    // fallback on the double value
<span class="fc" id="L251">                    result = Double.parseDouble(value);</span>
<span class="fc" id="L252">                }</span>
<span class="fc" id="L253">            } catch (NumberFormatException ex) {</span>
                // fallback on the string value
<span class="fc" id="L255">                result = value;</span>
<span class="fc" id="L256">            }</span>
        }

<span class="fc bfc" id="L259" title="All 2 branches covered.">        if (fieldType.equalsIgnoreCase(FIELD_TYPE_STRING)) {</span>
<span class="fc" id="L260">            result = value;</span>
        }

<span class="fc bfc" id="L263" title="All 4 branches covered.">        if (fieldType.equals(FIELD_TYPE_DOUBLE) || fieldType.equalsIgnoreCase(FIELD_TYPE_DOUBLE2)) {</span>
            try {
<span class="fc" id="L265">                result = Double.parseDouble(value);</span>
<span class="fc" id="L266">            } catch (NumberFormatException ex) {</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">                if (fieldType.equals(FIELD_TYPE_DOUBLE)) {</span>
<span class="fc" id="L268">                    result = Double.valueOf(0);</span>
                }
<span class="fc" id="L270">            }</span>
        }

<span class="fc bfc" id="L273" title="All 4 branches covered.">        if (fieldType.equals(FIELD_TYPE_LONG) || fieldType.equalsIgnoreCase(FIELD_TYPE_LONG2)) {</span>
            try {
<span class="fc" id="L275">                result = (long) Double.parseDouble(value);</span>
<span class="fc" id="L276">            } catch (NumberFormatException ex) {</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">                if (fieldType.equals(FIELD_TYPE_LONG)) {</span>
<span class="fc" id="L278">                    result = Long.valueOf(0);</span>
                }
<span class="fc" id="L280">            }</span>
        }

<span class="fc" id="L283">        return result;</span>
    }

    public ByteBuffer[] toUDPBuffers() {

<span class="fc" id="L288">        byte[] messageBytes = gzipMessage(toJsonByteArray(&quot;_&quot;));</span>

<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (messageBytes.length &gt; maximumMessageSize) {</span>
            // calculate the length of the datagrams array
<span class="fc" id="L292">            int datagrams_length = messageBytes.length / maximumMessageSize;</span>
            // In case of a remainder, due to the integer division, add a extra datagram
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">            if (messageBytes.length % maximumMessageSize != 0) {</span>
<span class="fc" id="L295">                datagrams_length++;</span>
            }

<span class="fc" id="L298">            ByteBuffer targetBuffer = ByteBuffer.allocate(messageBytes.length + (datagrams_length * 12));</span>

<span class="fc" id="L300">            return sliceDatagrams(ByteBuffer.wrap(messageBytes), datagrams_length, targetBuffer);</span>
        }

<span class="fc" id="L303">        ByteBuffer[] datagrams = new ByteBuffer[1];</span>
<span class="fc" id="L304">        datagrams[0] = ByteBuffer.allocate(messageBytes.length);</span>
<span class="fc" id="L305">        datagrams[0].put(messageBytes);</span>
<span class="fc" id="L306">        datagrams[0].flip();</span>
<span class="fc" id="L307">        return datagrams;</span>
    }

    public ByteBuffer[] toUDPBuffers(ByteBuffer buffer, ByteBuffer tempBuffer) {

<span class="fc" id="L312">        tempBuffer.put(gzipMessage(toJsonByteArray(&quot;_&quot;)));</span>

        // calculate the length of the datagrams array

<span class="fc bfc" id="L316" title="All 2 branches covered.">        if (tempBuffer.position() &gt; maximumMessageSize) {</span>

<span class="fc" id="L318">            int diagrams_length = tempBuffer.position() / maximumMessageSize;</span>
            // In case of a remainder, due to the integer division, add a extra datagram
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">            if (tempBuffer.position() % maximumMessageSize != 0) {</span>
<span class="fc" id="L321">                diagrams_length++;</span>
            }

<span class="fc" id="L324">            buffer.clear();</span>
<span class="fc" id="L325">            return sliceDatagrams((ByteBuffer) tempBuffer.flip(), diagrams_length, buffer);</span>
        }

<span class="fc" id="L328">        return new ByteBuffer[] { (ByteBuffer) tempBuffer.flip() };</span>
    }

    public ByteBuffer toTCPBuffer() {

        // Do not use GZIP, as the headers will contain \0 bytes
        // graylog2-server uses \0 as a delimiter for TCP frames
        // see: https://github.com/Graylog2/graylog2-server/issues/127
<span class="fc" id="L336">        byte[] messageBytes = toJsonByteArray(&quot;_&quot;);</span>

<span class="fc" id="L338">        ByteBuffer buffer = ByteBuffer.allocate(messageBytes.length + 1);</span>
<span class="fc" id="L339">        buffer.put(messageBytes);</span>
<span class="fc" id="L340">        buffer.put((byte) '\0');</span>
<span class="fc" id="L341">        buffer.flip();</span>
<span class="fc" id="L342">        return buffer;</span>
    }

    public ByteBuffer toTCPBuffer(ByteBuffer buffer) {
        // Do not use GZIP, as the headers will contain \0 bytes
        // graylog2-server uses \0 as a delimiter for TCP frames
        // see: https://github.com/Graylog2/graylog2-server/issues/127

<span class="fc" id="L350">        toJson(buffer, &quot;_&quot;);</span>

<span class="fc" id="L352">        buffer.put((byte) '\0');</span>
<span class="fc" id="L353">        buffer.flip();</span>
<span class="fc" id="L354">        return buffer;</span>
    }

    protected ByteBuffer[] sliceDatagrams(ByteBuffer source, int datagrams, ByteBuffer target) {
<span class="fc" id="L358">        int messageLength = source.limit();</span>

<span class="fc" id="L360">        int millis = getCurrentMillis();</span>

        // Reuse length of datagrams array since this is supposed to be the correct number of datagrams
<span class="fc" id="L363">        ByteBuffer[] slices = new ByteBuffer[datagrams];</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">        for (int idx = 0; idx &lt; datagrams; idx++) {</span>

<span class="fc" id="L366">            int start = target.position();</span>
<span class="fc" id="L367">            target.put(GELF_CHUNKED_ID).putInt(millis).put(hostBytes).put((byte) idx).put((byte) datagrams);</span>

<span class="fc" id="L369">            int from = idx * maximumMessageSize;</span>
<span class="fc" id="L370">            int to = from + maximumMessageSize;</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">            if (to &gt;= messageLength) {</span>
<span class="fc" id="L372">                to = messageLength;</span>
            }

<span class="fc" id="L375">            ByteBuffer duplicate = (ByteBuffer) source.duplicate().limit(to).position(from);</span>
<span class="fc" id="L376">            target.put(duplicate);</span>
<span class="fc" id="L377">            int end = target.position();</span>

<span class="fc" id="L379">            slices[idx] = (ByteBuffer) target.duplicate().limit(end).position(start);</span>
        }

<span class="fc" id="L382">        return slices;</span>
    }

    public int getCurrentMillis() {
<span class="fc" id="L386">        return (int) System.currentTimeMillis();</span>
    }

    private byte[] gzipMessage(byte[] message) {
<span class="fc" id="L390">        ByteArrayOutputStream bos = new ByteArrayOutputStream();</span>

        try {
<span class="fc" id="L393">            GZIPOutputStream stream = new GZIPOutputStream(bos);</span>

<span class="fc" id="L395">            stream.write(message);</span>
<span class="fc" id="L396">            stream.finish();</span>
<span class="fc" id="L397">            Closer.close(stream);</span>
<span class="fc" id="L398">            byte[] zipped = bos.toByteArray();</span>
<span class="fc" id="L399">            Closer.close(bos);</span>
<span class="fc" id="L400">            return zipped;</span>
<span class="nc" id="L401">        } catch (IOException e) {</span>
<span class="nc" id="L402">            return null;</span>
        }
    }

    private static byte[] lastFourAsciiBytes(String host) {
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">        final String shortHost = host.length() &gt;= 4 ? host.substring(host.length() - 4) : host;</span>
<span class="fc" id="L408">        return Charsets.ascii(shortHost);</span>
    }

    public String getVersion() {
<span class="fc" id="L412">        return version;</span>
    }

    public void setVersion(String version) {
<span class="fc" id="L416">        this.version = version;</span>
<span class="fc" id="L417">    }</span>

    public String getHost() {
<span class="fc" id="L420">        return host;</span>
    }

    public void setHost(String host) {
<span class="fc" id="L424">        this.host = host;</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">        if (host != null) {</span>
<span class="fc" id="L426">            this.hostBytes = lastFourAsciiBytes(host);</span>
        }
<span class="fc" id="L428">    }</span>

    public String getShortMessage() {
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">        return !isEmpty(shortMessage) ? shortMessage : &quot;&lt;empty&gt;&quot;;</span>
    }

    public void setShortMessage(String shortMessage) {
<span class="fc" id="L435">        this.shortMessage = shortMessage;</span>
<span class="fc" id="L436">    }</span>

    public String getFullMessage() {
<span class="fc" id="L439">        return fullMessage;</span>
    }

    public void setFullMessage(String fullMessage) {
<span class="fc" id="L443">        this.fullMessage = fullMessage;</span>
<span class="fc" id="L444">    }</span>

    public BigDecimal getTimestampAsBigDecimal() {
<span class="fc" id="L447">        return new BigDecimal(javaTimestamp).divide(TIME_DIVISOR);</span>
    }

    public String getTimestamp() {
<span class="fc" id="L451">        return getTimestampAsBigDecimal().toPlainString();</span>
    }

    public Long getJavaTimestamp() {
<span class="fc" id="L455">        return javaTimestamp;</span>
    }

    public void setJavaTimestamp(long javaTimestamp) {
<span class="fc" id="L459">        this.javaTimestamp = javaTimestamp;</span>
<span class="fc" id="L460">    }</span>

    public String getLevel() {
<span class="fc" id="L463">        return level;</span>
    }

    public void setLevel(String level) {
<span class="fc" id="L467">        this.level = level;</span>
<span class="fc" id="L468">    }</span>

    public String getFacility() {
<span class="fc" id="L471">        return facility;</span>
    }

    public void setFacility(String facility) {
<span class="fc" id="L475">        this.facility = facility;</span>
<span class="fc" id="L476">    }</span>

    public Map&lt;String, String&gt; getAdditionalFieldTypes() {
<span class="nc" id="L479">        return additionalFieldTypes;</span>
    }

    public void setAdditionalFieldTypes(Map&lt;String, String&gt; additionalFieldTypes) {
<span class="fc" id="L483">        this.additionalFieldTypes.putAll(additionalFieldTypes);</span>
<span class="fc" id="L484">    }</span>

    /**
     * Add multiple fields (key/value pairs)
     *
     * @param fields map of fields
     * @return the current GelfMessage.
     */
    public GelfMessage addFields(Map&lt;String, String&gt; fields) {

<span class="pc bpc" id="L494" title="1 of 2 branches missed.">        if (fields == null) {</span>
<span class="nc" id="L495">            throw new IllegalArgumentException(&quot;fields is null&quot;);</span>
        }

<span class="fc" id="L498">        getAdditonalFields().putAll(fields);</span>
<span class="fc" id="L499">        return this;</span>
    }

    /**
     * Add a particular field.
     *
     * @param key the key
     * @param value the value
     * @return the current GelfMessage.
     */
    public GelfMessage addField(String key, String value) {
<span class="fc" id="L510">        getAdditonalFields().put(key, value);</span>
<span class="fc" id="L511">        return this;</span>
    }

    public Map&lt;String, String&gt; getAdditonalFields() {
<span class="fc" id="L515">        return additonalFields;</span>
    }

    public boolean isValid() {
<span class="pc bpc" id="L519" title="2 of 6 branches missed.">        return isShortOrFullMessagesExists() &amp;&amp; !isEmpty(version) &amp;&amp; !isEmpty(host);</span>
    }

    private boolean isShortOrFullMessagesExists() {
<span class="pc bpc" id="L523" title="1 of 4 branches missed.">        return !isEmpty(shortMessage) || !isEmpty(fullMessage);</span>
    }

    public static boolean isEmpty(String str) {
<span class="fc bfc" id="L527" title="All 4 branches covered.">        return str == null || &quot;&quot;.equals(str.trim());</span>
    }

    public int getMaximumMessageSize() {
<span class="fc" id="L531">        return maximumMessageSize;</span>
    }

    public void setMaximumMessageSize(int maximumMessageSize) {
<span class="fc" id="L535">        this.maximumMessageSize = maximumMessageSize;</span>
<span class="fc" id="L536">    }</span>

    public String getField(String fieldName) {
<span class="fc" id="L539">        return getAdditonalFields().get(fieldName);</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">        if (this == o) {</span>
<span class="nc" id="L545">            return true;</span>
        }
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">        if (!(o instanceof GelfMessage)) {</span>
<span class="nc" id="L548">            return false;</span>
        }

<span class="fc" id="L551">        GelfMessage that = (GelfMessage) o;</span>

<span class="pc bpc" id="L553" title="1 of 2 branches missed.">        if (javaTimestamp != that.javaTimestamp) {</span>
<span class="nc" id="L554">            return false;</span>
        }
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">        if (maximumMessageSize != that.maximumMessageSize) {</span>
<span class="nc" id="L557">            return false;</span>
        }
<span class="pc bpc" id="L559" title="4 of 6 branches missed.">        if (additonalFields != null ? !additonalFields.equals(that.additonalFields) : that.additonalFields != null) {</span>
<span class="nc" id="L560">            return false;</span>
        }
<span class="pc bpc" id="L562" title="3 of 6 branches missed.">        if (facility != null ? !facility.equals(that.facility) : that.facility != null) {</span>
<span class="fc" id="L563">            return false;</span>
        }
<span class="pc bpc" id="L565" title="2 of 6 branches missed.">        if (fullMessage != null ? !fullMessage.equals(that.fullMessage) : that.fullMessage != null) {</span>
<span class="nc" id="L566">            return false;</span>
        }
<span class="pc bpc" id="L568" title="2 of 6 branches missed.">        if (host != null ? !host.equals(that.host) : that.host != null) {</span>
<span class="nc" id="L569">            return false;</span>
        }
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">        if (!Arrays.equals(hostBytes, that.hostBytes)) {</span>
<span class="nc" id="L572">            return false;</span>
        }
<span class="pc bpc" id="L574" title="2 of 6 branches missed.">        if (level != null ? !level.equals(that.level) : that.level != null) {</span>
<span class="nc" id="L575">            return false;</span>
        }
<span class="pc bpc" id="L577" title="2 of 6 branches missed.">        if (shortMessage != null ? !shortMessage.equals(that.shortMessage) : that.shortMessage != null) {</span>
<span class="nc" id="L578">            return false;</span>
        }
<span class="pc bpc" id="L580" title="4 of 6 branches missed.">        if (version != null ? !version.equals(that.version) : that.version != null) {</span>
<span class="nc" id="L581">            return false;</span>
        }

<span class="fc" id="L584">        return true;</span>
    }

    @Override
    public int hashCode() {
<span class="pc bpc" id="L589" title="1 of 2 branches missed.">        int result = version != null ? version.hashCode() : 0;</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">        result = 31 * result + (host != null ? host.hashCode() : 0);</span>
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">        result = 31 * result + (hostBytes != null ? Arrays.hashCode(hostBytes) : 0);</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">        result = 31 * result + (shortMessage != null ? shortMessage.hashCode() : 0);</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">        result = 31 * result + (fullMessage != null ? fullMessage.hashCode() : 0);</span>
<span class="fc" id="L594">        result = 31 * result + (int) (javaTimestamp ^ (javaTimestamp &gt;&gt;&gt; 32));</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">        result = 31 * result + (level != null ? level.hashCode() : 0);</span>
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">        result = 31 * result + (facility != null ? facility.hashCode() : 0);</span>
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">        result = 31 * result + (additonalFields != null ? additonalFields.hashCode() : 0);</span>
<span class="fc" id="L598">        result = 31 * result + maximumMessageSize;</span>
<span class="fc" id="L599">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>