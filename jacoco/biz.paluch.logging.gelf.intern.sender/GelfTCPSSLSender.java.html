<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GelfTCPSSLSender.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">logstash logging connectors</a> &gt; <a href="index.source.html" class="el_package">biz.paluch.logging.gelf.intern.sender</a> &gt; <span class="el_source">GelfTCPSSLSender.java</span></div><h1>GelfTCPSSLSender.java</h1><pre class="source lang-java linenums">package biz.paluch.logging.gelf.intern.sender;

import java.io.IOException;
import java.net.SocketException;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.util.concurrent.TimeUnit;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLSession;

import biz.paluch.logging.gelf.intern.ErrorReporter;

/**
 * TCP with SSL {@link biz.paluch.logging.gelf.intern.GelfSender}.
 * 
 * @author &lt;a href=&quot;mailto:mpaluch@paluch.biz&quot;&gt;Mark Paluch&lt;/a&gt;
 * @since 1.11
 */
public class GelfTCPSSLSender extends GelfTCPSender {

    private final SSLContext sslContext;
<span class="nc" id="L25">    private final ThreadLocal&lt;ByteBuffer&gt; sslNetworkBuffers = new ThreadLocal&lt;ByteBuffer&gt;();</span>
<span class="nc" id="L26">	private final ThreadLocal&lt;ByteBuffer&gt; tempBuffers = new ThreadLocal&lt;ByteBuffer&gt;();</span>

	private volatile SSLEngine sslEngine;

    private volatile SSLSession sslSession;

    /**
     * @param host the host, must not be {@literal null}.
     * @param port the port.
     * @param connectTimeoutMs connection timeout, in {@link TimeUnit#MILLISECONDS}.
     * @param readTimeoutMs read timeout, in {@link TimeUnit#MILLISECONDS}.
     * @param deliveryAttempts number of delivery attempts.
     * @param keepAlive {@literal true} to enable TCP keep-alive.
     * @param errorReporter the error reporter, must not be {@literal null}.
     * @param sslContext the SSL context, must not be {@literal null}.
     * @throws IOException in case of I/O errors
     */
    public GelfTCPSSLSender(String host, int port, int connectTimeoutMs, int readTimeoutMs, int deliveryAttempts,
            boolean keepAlive, ErrorReporter errorReporter, SSLContext sslContext) throws IOException {

<span class="nc" id="L46">        super(host, port, connectTimeoutMs, readTimeoutMs, deliveryAttempts, keepAlive, errorReporter);</span>

<span class="nc" id="L48">        this.sslContext = sslContext;</span>
<span class="nc" id="L49">    }</span>

    @Override
    protected boolean connect() throws IOException {

<span class="nc" id="L54">		this.sslEngine = sslContext.createSSLEngine();</span>
<span class="nc" id="L55">		this.sslEngine.setUseClientMode(true);</span>
<span class="nc" id="L56">        this.sslSession = sslEngine.getSession();</span>

<span class="nc bnc" id="L58" title="All 2 branches missed.">        if (super.connect()) {</span>
            // Begin handshake
<span class="nc" id="L60">            sslEngine.beginHandshake();</span>
<span class="nc" id="L61">            doHandshake(channel(), sslEngine, ByteBuffer.allocate(sslSession.getPacketBufferSize()),</span>
                    ByteBuffer.allocate(sslSession.getPacketBufferSize()));
        }
<span class="nc" id="L64">        return false;</span>
    }

    protected boolean isConnected() throws IOException {

<span class="nc bnc" id="L69" title="All 6 branches missed.">        if (channel() != null &amp;&amp; channel().isOpen() &amp;&amp; isConnected(channel())) {</span>
<span class="nc" id="L70">            return true;</span>
        }

<span class="nc" id="L73">        return false;</span>
    }

    @Override
    protected void write(ByteBuffer gelfBuffer) throws IOException {

<span class="nc bnc" id="L79" title="All 2 branches missed.">        while (gelfBuffer.hasRemaining()) {</span>

<span class="nc" id="L81">            read();</span>

<span class="nc" id="L83">            ByteBuffer myNetData = getNetworkBuffer();</span>
            // Generate SSL/TLS encoded data (handshake or application data)
<span class="nc" id="L85">            gelfBuffer.mark();</span>
<span class="nc" id="L86">            SSLEngineResult res = sslEngine.wrap(gelfBuffer, myNetData);</span>

            // Process status of call
<span class="nc bnc" id="L89" title="All 2 branches missed.">            if (res.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {</span>
<span class="nc" id="L90">                this.sslNetworkBuffers.set(enlargeBuffer(gelfBuffer, myNetData));</span>
<span class="nc" id="L91">                gelfBuffer.reset();</span>
            }

<span class="nc bnc" id="L94" title="All 2 branches missed.">            if (res.getStatus() == SSLEngineResult.Status.OK) {</span>
<span class="nc" id="L95">                myNetData.flip();</span>

                // Send SSL/TLS encoded data to peer
<span class="nc bnc" id="L98" title="All 2 branches missed.">                while (myNetData.hasRemaining()) {</span>
<span class="nc" id="L99">                    int written = channel().write(myNetData);</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">                    if (written == -1) {</span>
<span class="nc" id="L101">                        throw new SocketException(&quot;Channel closed&quot;);</span>
                    }
<span class="nc" id="L103">                }</span>
            }
<span class="nc" id="L105">        }</span>
<span class="nc" id="L106">    }</span>

    private void read() throws IOException {

<span class="nc" id="L110">        ByteBuffer myNetData = getNetworkBuffer();</span>
<span class="nc" id="L111">        ByteBuffer tempBuffer = getTempBuffer();</span>

<span class="nc bnc" id="L113" title="All 2 branches missed.">        if (channel().read(myNetData) &lt; 0) {</span>
<span class="nc" id="L114">            throw new SocketException(&quot;Channel closed&quot;);</span>
        }

        // Process incoming handshaking data
<span class="nc" id="L118">        myNetData.flip();</span>
<span class="nc" id="L119">        sslEngine.unwrap(myNetData, tempBuffer);</span>
<span class="nc" id="L120">    }</span>

    private ByteBuffer getNetworkBuffer() {

<span class="nc" id="L124">        ByteBuffer networkBuffer = this.sslNetworkBuffers.get();</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">        if (networkBuffer == null) {</span>
<span class="nc" id="L126">            this.sslNetworkBuffers.set(networkBuffer = ByteBuffer.allocateDirect(sslSession.getPacketBufferSize()));</span>
        }
<span class="nc" id="L128">        networkBuffer.clear();</span>
<span class="nc" id="L129">        return networkBuffer;</span>
    }

    private ByteBuffer getTempBuffer() {

<span class="nc" id="L134">        ByteBuffer tempBuffer = this.tempBuffers.get();</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (tempBuffer == null) {</span>
<span class="nc" id="L136">            this.tempBuffers.set(tempBuffer = ByteBuffer.allocateDirect(sslSession.getApplicationBufferSize()));</span>
        }
<span class="nc" id="L138">        tempBuffer.clear();</span>
<span class="nc" id="L139">        return tempBuffer;</span>
    }

    private ByteBuffer enlargeBuffer(ByteBuffer src, ByteBuffer dst) {

        // Could attempt to drain the dst buffer of any already obtained
        // data, but we'll just increase it to the size needed.
<span class="nc" id="L146">        ByteBuffer buffer = ByteBuffer.allocate(dst.capacity() + src.remaining());</span>
<span class="nc" id="L147">        dst.flip();</span>
<span class="nc" id="L148">        buffer.put(dst);</span>
<span class="nc" id="L149">        return buffer;</span>

    }

    private void doHandshake(SocketChannel socketChannel, SSLEngine sslEngine, ByteBuffer myNetData, ByteBuffer peerNetData)
            throws IOException {

        // Create byte buffers to use for holding application data
<span class="nc" id="L157">        int appBufferSize = sslEngine.getSession().getApplicationBufferSize();</span>
<span class="nc" id="L158">        ByteBuffer myAppData = ByteBuffer.allocate(appBufferSize);</span>
<span class="nc" id="L159">        ByteBuffer peerAppData = ByteBuffer.allocate(appBufferSize);</span>

<span class="nc" id="L161">        SSLEngineResult.HandshakeStatus hs = sslEngine.getHandshakeStatus();</span>

        // Process handshaking message
<span class="nc bnc" id="L164" title="All 4 branches missed.">        while (hs != SSLEngineResult.HandshakeStatus.FINISHED &amp;&amp; hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {</span>

<span class="nc bnc" id="L166" title="All 5 branches missed.">            switch (hs) {</span>

                case NEED_UNWRAP:
                    // Receive handshaking data from peer
<span class="nc bnc" id="L170" title="All 2 branches missed.">                    if (socketChannel.read(peerNetData) &lt; 0) {</span>
<span class="nc" id="L171">                        throw new SocketException(&quot;Channel closed&quot;);</span>
                    }

                    // Process incoming handshaking data
<span class="nc" id="L175">                    peerNetData.flip();</span>
<span class="nc" id="L176">                    SSLEngineResult res = sslEngine.unwrap(peerNetData, peerAppData);</span>
<span class="nc" id="L177">                    peerNetData.compact();</span>
<span class="nc" id="L178">                    hs = res.getHandshakeStatus();</span>

                    // Check status
<span class="nc bnc" id="L181" title="All 3 branches missed.">                    switch (res.getStatus()) {</span>
                        case OK:
                            // Handle OK status
<span class="nc" id="L184">                            break;</span>
                        case BUFFER_OVERFLOW:
<span class="nc" id="L186">                            peerAppData = enlargeBuffer(peerNetData, peerAppData);</span>
<span class="nc" id="L187">                            break;</span>

                        case BUFFER_UNDERFLOW:

                            break;
                    }
<span class="nc" id="L193">                    break;</span>

                case NEED_WRAP:
                    // Empty the local network packet buffer.
<span class="nc" id="L197">                    myNetData.clear();</span>

                    // Generate handshaking data
<span class="nc" id="L200">                    res = sslEngine.wrap(myAppData, myNetData);</span>
<span class="nc" id="L201">                    hs = res.getHandshakeStatus();</span>

                    // Check status
<span class="nc bnc" id="L204" title="All 5 branches missed.">                    switch (res.getStatus()) {</span>
                        case OK:
<span class="nc" id="L206">                            myNetData.flip();</span>

                            // Send the handshaking data to peer
<span class="nc bnc" id="L209" title="All 2 branches missed.">                            while (myNetData.hasRemaining()) {</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">                                if (socketChannel.write(myNetData) &lt; 0) {</span>
                                    // Handle closed channel
                                }
                            }
                            break;
                        case BUFFER_OVERFLOW:
<span class="nc" id="L216">                            myNetData = enlargeBuffer(myAppData, myNetData);</span>
<span class="nc" id="L217">                            break;</span>

                        case BUFFER_UNDERFLOW:
<span class="nc" id="L220">                            break;</span>
                        case CLOSED:

<span class="nc bnc" id="L223" title="All 2 branches missed.">                            if (sslEngine.isOutboundDone()) {</span>
<span class="nc" id="L224">                                return;</span>
                            } else {
<span class="nc" id="L226">                                sslEngine.closeOutbound();</span>
<span class="nc" id="L227">                                hs = sslEngine.getHandshakeStatus();</span>
<span class="nc" id="L228">                                break;</span>
                            }

                        default:
<span class="nc" id="L232">                            throw new IOException(&quot;Cannot wrap data: &quot; + res.getStatus());</span>

                    }
                    break;

                case NEED_TASK:
                    Runnable task;
<span class="nc bnc" id="L239" title="All 2 branches missed.">                    while ((task = sslEngine.getDelegatedTask()) != null) {</span>
<span class="nc" id="L240">                        task.run();</span>
                    }
<span class="nc" id="L242">                    hs = sslEngine.getHandshakeStatus();</span>
<span class="nc" id="L243">                    break;</span>

                case FINISHED:
<span class="nc" id="L246">                    return;</span>
            }
        }
<span class="nc" id="L249">    }</span>

    @Override
    public void close() {

<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (channel() != null) {</span>

            try {
<span class="nc" id="L257">                closeSocketChannel();</span>
<span class="nc" id="L258">            } catch (IOException e) {</span>
<span class="nc" id="L259">                reportError(e.getMessage(), e);</span>
<span class="nc" id="L260">            }</span>
        }

<span class="nc" id="L263">        super.close();</span>
<span class="nc" id="L264">    }</span>

    private void closeSocketChannel() throws IOException {

<span class="nc" id="L268">        sslEngine.closeOutbound();</span>
<span class="nc" id="L269">        doHandshake(channel(), sslEngine, ByteBuffer.allocate(sslSession.getPacketBufferSize()),</span>
                ByteBuffer.allocate(sslSession.getPacketBufferSize()));
<span class="nc" id="L271">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>