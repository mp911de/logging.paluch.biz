<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GelfTCPSSLSender.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">logstash logging connectors</a> &gt; <a href="index.source.html" class="el_package">biz.paluch.logging.gelf.intern.sender</a> &gt; <span class="el_source">GelfTCPSSLSender.java</span></div><h1>GelfTCPSSLSender.java</h1><pre class="source lang-java linenums">package biz.paluch.logging.gelf.intern.sender;

import java.io.IOException;
import java.net.SocketException;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.util.concurrent.TimeUnit;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLSession;

import biz.paluch.logging.gelf.intern.ErrorReporter;

/**
 * TCP with SSL {@link biz.paluch.logging.gelf.intern.GelfSender}.
 *
 * @author &lt;a href=&quot;mailto:mpaluch@paluch.biz&quot;&gt;Mark Paluch&lt;/a&gt;
 * @since 1.11
 */
public class GelfTCPSSLSender extends GelfTCPSender {

    private final SSLContext sslContext;
<span class="fc" id="L25">    private final ThreadLocal&lt;ByteBuffer&gt; sslNetworkBuffers = new ThreadLocal&lt;ByteBuffer&gt;();</span>
<span class="fc" id="L26">    private final ThreadLocal&lt;ByteBuffer&gt; tempBuffers = new ThreadLocal&lt;ByteBuffer&gt;();</span>

    private volatile SSLEngine sslEngine;

    private volatile SSLSession sslSession;

    /**
     * @param host the host, must not be {@literal null}.
     * @param port the port.
     * @param connectTimeoutMs connection timeout, in {@link TimeUnit#MILLISECONDS}.
     * @param readTimeoutMs read timeout, in {@link TimeUnit#MILLISECONDS}.
     * @param deliveryAttempts number of delivery attempts.
     * @param keepAlive {@literal true} to enable TCP keep-alive.
     * @param errorReporter the error reporter, must not be {@literal null}.
     * @param sslContext the SSL context, must not be {@literal null}.
     * @throws IOException in case of I/O errors
     */
    public GelfTCPSSLSender(String host, int port, int connectTimeoutMs, int readTimeoutMs, int deliveryAttempts,
            boolean keepAlive, ErrorReporter errorReporter, SSLContext sslContext) throws IOException {

<span class="fc" id="L46">        super(host, port, connectTimeoutMs, readTimeoutMs, deliveryAttempts, keepAlive, errorReporter);</span>

<span class="fc" id="L48">        this.sslContext = sslContext;</span>
<span class="fc" id="L49">    }</span>

    @Override
    protected boolean connect() throws IOException {

<span class="nc" id="L54">        this.sslEngine = sslContext.createSSLEngine();</span>
<span class="nc" id="L55">        this.sslEngine.setUseClientMode(true);</span>
<span class="nc" id="L56">        this.sslSession = sslEngine.getSession();</span>

<span class="nc bnc" id="L58" title="All 2 branches missed.">        if (super.connect()) {</span>
            // Begin handshake
<span class="nc" id="L60">            sslEngine.beginHandshake();</span>
<span class="nc" id="L61">            doHandshake(channel(), sslEngine, ByteBuffer.allocate(sslSession.getPacketBufferSize()),</span>
<span class="nc" id="L62">                    ByteBuffer.allocate(sslSession.getPacketBufferSize()));</span>
        }
<span class="nc" id="L64">        return false;</span>
    }

    protected boolean isConnected() throws IOException {

<span class="nc" id="L69">        SocketChannel socketChannel = channel();</span>

<span class="nc bnc" id="L71" title="All 6 branches missed.">        return socketChannel != null &amp;&amp; socketChannel.isOpen() &amp;&amp; isConnected(socketChannel);</span>
    }

    @Override
    protected void write(ByteBuffer gelfBuffer) throws IOException {

<span class="nc bnc" id="L77" title="All 2 branches missed.">        while (gelfBuffer.hasRemaining()) {</span>

<span class="nc" id="L79">            read();</span>

<span class="nc" id="L81">            ByteBuffer myNetData = getNetworkBuffer();</span>
            // Generate SSL/TLS encoded data (handshake or application data)
<span class="nc" id="L83">            gelfBuffer.mark();</span>
<span class="nc" id="L84">            SSLEngineResult res = sslEngine.wrap(gelfBuffer, myNetData);</span>

            // Process status of call
<span class="nc bnc" id="L87" title="All 2 branches missed.">            if (res.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {</span>
<span class="nc" id="L88">                this.sslNetworkBuffers.set(enlargeBuffer(gelfBuffer, myNetData));</span>
<span class="nc" id="L89">                gelfBuffer.reset();</span>
            }

<span class="nc bnc" id="L92" title="All 2 branches missed.">            if (res.getStatus() == SSLEngineResult.Status.OK) {</span>
<span class="nc" id="L93">                myNetData.flip();</span>

                // Send SSL/TLS encoded data to peer
<span class="nc bnc" id="L96" title="All 2 branches missed.">                while (myNetData.hasRemaining()) {</span>
<span class="nc" id="L97">                    int written = channel().write(myNetData);</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                    if (written == -1) {</span>
<span class="nc" id="L99">                        throw new SocketException(&quot;Channel closed&quot;);</span>
                    }
<span class="nc" id="L101">                }</span>
            }
<span class="nc" id="L103">        }</span>
<span class="nc" id="L104">    }</span>

    private void read() throws IOException {

<span class="nc" id="L108">        ByteBuffer myNetData = getNetworkBuffer();</span>
<span class="nc" id="L109">        ByteBuffer tempBuffer = getTempBuffer();</span>

<span class="nc bnc" id="L111" title="All 2 branches missed.">        if (channel().read(myNetData) &lt; 0) {</span>
<span class="nc" id="L112">            throw new SocketException(&quot;Channel closed&quot;);</span>
        }

        // Process incoming handshaking data
<span class="nc" id="L116">        myNetData.flip();</span>
<span class="nc" id="L117">        sslEngine.unwrap(myNetData, tempBuffer);</span>
<span class="nc" id="L118">    }</span>

    private ByteBuffer getNetworkBuffer() {

<span class="nc" id="L122">        ByteBuffer networkBuffer = this.sslNetworkBuffers.get();</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">        if (networkBuffer == null) {</span>
<span class="nc" id="L124">            this.sslNetworkBuffers.set(networkBuffer = ByteBuffer.allocateDirect(sslSession.getPacketBufferSize()));</span>
        }
<span class="nc" id="L126">        networkBuffer.clear();</span>
<span class="nc" id="L127">        return networkBuffer;</span>
    }

    private ByteBuffer getTempBuffer() {

<span class="nc" id="L132">        ByteBuffer tempBuffer = this.tempBuffers.get();</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">        if (tempBuffer == null) {</span>
<span class="nc" id="L134">            this.tempBuffers.set(tempBuffer = ByteBuffer.allocateDirect(sslSession.getApplicationBufferSize()));</span>
        }
<span class="nc" id="L136">        tempBuffer.clear();</span>
<span class="nc" id="L137">        return tempBuffer;</span>
    }

    private ByteBuffer enlargeBuffer(ByteBuffer src, ByteBuffer dst) {

        // Could attempt to drain the dst buffer of any already obtained
        // data, but we'll just increase it to the size needed.
<span class="nc" id="L144">        ByteBuffer buffer = ByteBuffer.allocate(dst.capacity() + src.remaining());</span>
<span class="nc" id="L145">        dst.flip();</span>
<span class="nc" id="L146">        buffer.put(dst);</span>
<span class="nc" id="L147">        return buffer;</span>
    }

    private void doHandshake(SocketChannel socketChannel, SSLEngine sslEngine, ByteBuffer myNetData, ByteBuffer peerNetData)
            throws IOException {

        // Create byte buffers to use for holding application data
<span class="nc" id="L154">        int appBufferSize = sslEngine.getSession().getApplicationBufferSize();</span>
<span class="nc" id="L155">        ByteBuffer myAppData = ByteBuffer.allocate(appBufferSize);</span>
<span class="nc" id="L156">        ByteBuffer peerAppData = ByteBuffer.allocate(appBufferSize);</span>

<span class="nc" id="L158">        SSLEngineResult.HandshakeStatus hs = sslEngine.getHandshakeStatus();</span>

        // Process handshaking message
<span class="nc bnc" id="L161" title="All 4 branches missed.">        while (hs != SSLEngineResult.HandshakeStatus.FINISHED &amp;&amp; hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {</span>

<span class="nc bnc" id="L163" title="All 5 branches missed.">            switch (hs) {</span>

                case NEED_UNWRAP:
                    // Receive handshaking data from peer
<span class="nc bnc" id="L167" title="All 2 branches missed.">                    if (socketChannel.read(peerNetData) &lt; 0) {</span>
<span class="nc" id="L168">                        throw new SocketException(&quot;Channel closed&quot;);</span>
                    }

                    // Process incoming handshaking data
<span class="nc" id="L172">                    peerNetData.flip();</span>
<span class="nc" id="L173">                    SSLEngineResult res = sslEngine.unwrap(peerNetData, peerAppData);</span>
<span class="nc" id="L174">                    peerNetData.compact();</span>
<span class="nc" id="L175">                    hs = res.getHandshakeStatus();</span>

                    // Check status
<span class="nc bnc" id="L178" title="All 3 branches missed.">                    switch (res.getStatus()) {</span>
                        case OK:
                            // Handle OK status
<span class="nc" id="L181">                            break;</span>
                        case BUFFER_OVERFLOW:
<span class="nc" id="L183">                            peerAppData = enlargeBuffer(peerNetData, peerAppData);</span>
<span class="nc" id="L184">                            break;</span>

                        case BUFFER_UNDERFLOW:

                            break;
                    }
<span class="nc" id="L190">                    break;</span>

                case NEED_WRAP:
                    // Empty the local network packet buffer.
<span class="nc" id="L194">                    myNetData.clear();</span>

                    // Generate handshaking data
<span class="nc" id="L197">                    res = sslEngine.wrap(myAppData, myNetData);</span>
<span class="nc" id="L198">                    hs = res.getHandshakeStatus();</span>

                    // Check status
<span class="nc bnc" id="L201" title="All 5 branches missed.">                    switch (res.getStatus()) {</span>
                        case OK:
<span class="nc" id="L203">                            myNetData.flip();</span>

                            // Send the handshaking data to peer
<span class="nc bnc" id="L206" title="All 2 branches missed.">                            while (myNetData.hasRemaining()) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">                                if (socketChannel.write(myNetData) &lt; 0) {</span>
                                    // Handle closed channel
                                }
                            }
                            break;
                        case BUFFER_OVERFLOW:
<span class="nc" id="L213">                            myNetData = enlargeBuffer(myAppData, myNetData);</span>
<span class="nc" id="L214">                            break;</span>

                        case BUFFER_UNDERFLOW:
<span class="nc" id="L217">                            break;</span>
                        case CLOSED:

<span class="nc bnc" id="L220" title="All 2 branches missed.">                            if (sslEngine.isOutboundDone()) {</span>
<span class="nc" id="L221">                                return;</span>
                            } else {
<span class="nc" id="L223">                                sslEngine.closeOutbound();</span>
<span class="nc" id="L224">                                hs = sslEngine.getHandshakeStatus();</span>
<span class="nc" id="L225">                                break;</span>
                            }

                        default:
<span class="nc" id="L229">                            throw new IOException(&quot;Cannot wrap data: &quot; + res.getStatus());</span>

                    }
                    break;

                case NEED_TASK:
                    Runnable task;
<span class="nc bnc" id="L236" title="All 2 branches missed.">                    while ((task = sslEngine.getDelegatedTask()) != null) {</span>
<span class="nc" id="L237">                        task.run();</span>
                    }
<span class="nc" id="L239">                    hs = sslEngine.getHandshakeStatus();</span>
<span class="nc" id="L240">                    break;</span>

                case FINISHED:
<span class="nc" id="L243">                    return;</span>
            }
        }
<span class="nc" id="L246">    }</span>

    @Override
    public void close() {

<span class="pc bpc" id="L251" title="1 of 2 branches missed.">        if (channel() != null) {</span>

            try {
<span class="fc" id="L254">                closeSocketChannel();</span>
<span class="nc" id="L255">            } catch (IOException e) {</span>
<span class="nc" id="L256">                reportError(e.getMessage(), e);</span>
<span class="fc" id="L257">            }</span>
        }

<span class="fc" id="L260">        super.close();</span>
<span class="fc" id="L261">    }</span>

    private void closeSocketChannel() throws IOException {

<span class="pc bpc" id="L265" title="1 of 2 branches missed.">        if (sslEngine != null) {</span>

<span class="nc" id="L267">            sslEngine.closeOutbound();</span>

<span class="nc bnc" id="L269" title="All 2 branches missed.">            if (sslSession != null) {</span>
<span class="nc" id="L270">                doHandshake(channel(), sslEngine, ByteBuffer.allocate(sslSession.getPacketBufferSize()),</span>
<span class="nc" id="L271">                        ByteBuffer.allocate(sslSession.getPacketBufferSize()));</span>
            }
        }
<span class="fc" id="L274">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>